# -*- coding: utf-8 -*-
"""Copie de Antenna array 2D beam forming ANN - SNN

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18fJu0harcdhmIZ4HtullT91WQjtf15Pe

# Intro

This notebook steps through a simple example of a two-dimensional array of
antennas forming a single narrow beam for a single frequency towards a target angle.

It shows three different methods of optimisation to arrive at feed parameters (amplitudes and phases) for the array:


1.   Standard iterative gradient descent optimiser.
2.   Training an Artifical Neural Network (ANN).
3.   Training a Spiking Neural Network (SNN).

We ignore the fact that the scenario is so simple as to possibly permit analytic solutions, since the aim will be to increase the complexity of the scenario towards a realistic one for satellite communications.

We include basic approaches to estimating energy consumption for ANN vs SNN, where these initial estimates are based on principles rather than in reference to any specific computational hardware.
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from mpl_toolkits import mplot3d


## Antenna array definition

# The antenna coords 
antenna_coords = np.array([[0.0, 0.0], [0.03, 0.0], [0.015, 0.025], [-0.014, 0.025], [-0.03, 0.0], [-0.015, -0.025], [0.015, -0.025], [0.06, 0.0], [0.051, 0.029], [0.03, 0.051], [0.0, 0.06], [-0.029, 0.051], [-0.051, 0.029], [-0.06, 0.0], [-0.051, -0.029], [-0.03, -0.051], [0.0, -0.06], [0.03, -0.051], [0.051, -0.03], [0.09, 0.0], [0.084, 0.03], [0.068, 0.057], [0.045, 0.077], [0.015, 0.088], [-0.015, 0.088], [-0.044, 0.077], [-0.068, 0.057], [-0.084, 0.03], [-0.09, 0.0], [-0.084, -0.03], [-0.068, -0.057], [-0.045, -0.077], [-0.015, -0.088], [0.015, -0.088], [0.044, -0.077], [0.068, -0.057], [0.084, -0.03], [0.12, 0.0], [0.115, 0.031], [0.103, 0.059], [0.084, 0.084], [0.06, 0.103], [0.031, 0.115], [0.0, 0.12], [-0.031, 0.115], [-0.059, 0.103], [-0.084, 0.084], [-0.103, 0.059], [-0.115, 0.031], [-0.12, 0.0], [-0.115, -0.031], [-0.103, -0.059], [-0.084, -0.084], [-0.06, -0.103], [-0.031, -0.115], [0.0, -0.12], [0.031, -0.115], [0.06, -0.103], [0.084, -0.084], [0.103, -0.06], [0.115, -0.031], [0.15, 0.0], [0.146, 0.031], [0.137, 0.061], [0.121, 0.088], [0.1, 0.111], [0.075, 0.129], [0.046, 0.142], [0.015, 0.149], [-0.015, 0.149], [-0.046, 0.142], [-0.074, 0.129], [-0.1, 0.111], [-0.121, 0.088], [-0.137, 0.061], [-0.146, 0.031], [-0.15, 0.0], [-0.146, -0.031], [-0.137, -0.061], [-0.121, -0.088], [-0.1, -0.111], [-0.075, -0.129], [-0.046, -0.142], [-0.015, -0.149], [0.015, -0.149], [0.046, -0.142], [0.075, -0.129], [0.1, -0.111], [0.121, -0.088], [0.137, -0.061], [0.146, -0.031], [0.18, 0.0], [0.177, 0.031], [0.169, 0.061], [0.155, 0.089], [0.137, 0.115], [0.115, 0.137], [0.09, 0.155], [0.061, 0.169], [0.031, 0.177], [0.0, 0.18], [-0.031, 0.177], [-0.061, 0.169], [-0.089, 0.155], [-0.115, 0.137], [-0.137, 0.115], [-0.155, 0.09], [-0.169, 0.061], [-0.177, 0.031], [-0.18, 0.0], [-0.177, -0.031], [-0.169, -0.061], [-0.155, -0.09], [-0.137, -0.115], [-0.115, -0.137], [-0.09, -0.155], [-0.061, -0.169], [-0.031, -0.177], [0.0, -0.18], [0.031, -0.177], [0.061, -0.169], [0.089, -0.155], [0.115, -0.137], [0.137, -0.115], [0.155, -0.089], [0.169, -0.061], [0.177, -0.031], [0.21, 0.0], [0.207, 0.031], [0.2, 0.061], [0.189, 0.091], [0.173, 0.118], [0.153, 0.142], [0.13, 0.164], [0.105, 0.181], [0.076, 0.195], [0.046, 0.204], [0.015, 0.209], [-0.015, 0.209], [-0.046, 0.204], [-0.076, 0.195], [-0.104, 0.181], [-0.13, 0.164], [-0.153, 0.142], [-0.173, 0.118], [-0.189, 0.091], [-0.2, 0.061], [-0.207, 0.031], [-0.21, 0.0], [-0.207, -0.031], [-0.2, -0.061], [-0.189, -0.091], [-0.173, -0.118], [-0.153, -0.142], [-0.13, -0.164], [-0.105, -0.181], [-0.076, -0.195], [-0.046, -0.204], [-0.015, -0.209], [0.015, -0.209], [0.046, -0.204], [0.076, -0.195], [0.104, -0.181], [0.13, -0.164], [0.153, -0.142], [0.173, -0.118], [0.189, -0.091], [0.2, -0.061], [0.207, -0.031], [0.24, 0.0], [0.237, 0.031], [0.231, 0.062], [0.221, 0.091], [0.207, 0.119], [0.19, 0.146], [0.169, 0.169], [0.146, 0.19], [0.12, 0.207], [0.091, 0.221], [0.062, 0.231], [0.031, 0.237], [0.0, 0.24], [-0.031, 0.237], [-0.062, 0.231], [-0.091, 0.221], [-0.119, 0.207], [-0.146, 0.19], [-0.169, 0.169], [-0.19, 0.146], [-0.207, 0.119], [-0.221, 0.091], [-0.231, 0.062], [-0.237, 0.031], [-0.24, 0.0], [-0.237, -0.031], [-0.231, -0.062], [-0.221, -0.091], [-0.207, -0.119], [-0.19, -0.146], [-0.169, -0.169], [-0.146, -0.19], [-0.12, -0.207], [-0.091, -0.221], [-0.062, -0.231], [-0.031, -0.237], [0.0, -0.24], [0.031, -0.237], [0.062, -0.231], [0.091, -0.221], [0.12, -0.207], [0.146, -0.19], [0.169, -0.169], [0.19, -0.146], [0.207, -0.12], [0.221, -0.091], [0.231, -0.062], [0.237, -0.031], [0.27, 0.0], [0.268, 0.031], [0.262, 0.062], [0.253, 0.092], [0.241, 0.121], [0.225, 0.148], [0.206, 0.173], [0.185, 0.196], [0.161, 0.216], [0.135, 0.233], [0.106, 0.247], [0.077, 0.258], [0.046, 0.265], [0.015, 0.269], [-0.015, 0.269], [-0.046, 0.265], [-0.077, 0.258], [-0.106, 0.247], [-0.134, 0.233], [-0.161, 0.216], [-0.185, 0.196], [-0.206, 0.173], [-0.225, 0.148], [-0.241, 0.121], [-0.253, 0.092], [-0.262, 0.062], [-0.268, 0.031], [-0.27, 0.0], [-0.268, -0.031], [-0.262, -0.062], [-0.253, -0.092], [-0.241, -0.121], [-0.225, -0.148], [-0.206, -0.173], [-0.185, -0.196], [-0.161, -0.216], [-0.135, -0.233], [-0.106, -0.247], [-0.077, -0.258], [-0.046, -0.265], [-0.015, -0.269], [0.015, -0.269], [0.046, -0.265], [0.077, -0.258], [0.106, -0.247], [0.135, -0.233], [0.161, -0.216], [0.185, -0.196], [0.206, -0.173], [0.225, -0.148], [0.241, -0.121], [0.253, -0.092], [0.262, -0.062], [0.268, -0.031], [0.3, 0.0], [0.298, 0.031], [0.293, 0.062], [0.285, 0.092], [0.274, 0.122], [0.259, 0.149], [0.242, 0.176], [0.222, 0.2], [0.2, 0.222], [0.176, 0.242], [0.15, 0.259], [0.122, 0.274], [0.092, 0.285], [0.062, 0.293], [0.031, 0.298], [0.0, 0.3], [-0.031, 0.298], [-0.062, 0.293], [-0.092, 0.285], [-0.122, 0.274], [-0.149, 0.259], [-0.176, 0.242], [-0.2, 0.222], [-0.222, 0.2], [-0.242, 0.176], [-0.259, 0.149], [-0.274, 0.122], [-0.285, 0.092], [-0.293, 0.062], [-0.298, 0.031], [-0.3, 0.0], [-0.298, -0.031], [-0.293, -0.062], [-0.285, -0.092], [-0.274, -0.122], [-0.259, -0.149], [-0.242, -0.176], [-0.222, -0.2], [-0.2, -0.222], [-0.176, -0.242], [-0.15, -0.259], [-0.122, -0.274], [-0.092, -0.285], [-0.062, -0.293], [-0.031, -0.298], [0.0, -0.3], [0.031, -0.298], [0.062, -0.293], [0.092, -0.285], [0.122, -0.274], [0.15, -0.259], [0.176, -0.242], [0.2, -0.222], [0.222, -0.2], [0.242, -0.176], [0.259, -0.149], [0.274, -0.122], [0.285, -0.092], [0.293, -0.062], [0.298, -0.031], [0.33, 0.0], [0.328, 0.031], [0.324, 0.062], [0.316, 0.092], [0.306, 0.122], [0.293, 0.151], [0.277, 0.178], [0.259, 0.203], [0.238, 0.227], [0.216, 0.249], [0.191, 0.268], [0.165, 0.285], [0.137, 0.3], [0.107, 0.311], [0.077, 0.32], [0.046, 0.326], [0.015, 0.329], [-0.015, 0.329], [-0.046, 0.326], [-0.077, 0.32], [-0.107, 0.311], [-0.137, 0.3], [-0.164, 0.285], [-0.191, 0.268], [-0.216, 0.249], [-0.238, 0.227], [-0.259, 0.203], [-0.277, 0.178], [-0.293, 0.151], [-0.306, 0.122], [-0.316, 0.092], [-0.324, 0.062], [-0.328, 0.031], [-0.33, 0.0], [-0.328, -0.031], [-0.324, -0.062], [-0.316, -0.092], [-0.306, -0.122], [-0.293, -0.151], [-0.277, -0.178], [-0.259, -0.203], [-0.238, -0.227], [-0.216, -0.249], [-0.191, -0.268], [-0.165, -0.285], [-0.137, -0.3], [-0.107, -0.311], [-0.077, -0.32], [-0.046, -0.326], [-0.015, -0.329], [0.015, -0.329], [0.046, -0.326], [0.077, -0.32], [0.107, -0.311], [0.137, -0.3], [0.165, -0.285], [0.191, -0.268], [0.216, -0.249], [0.238, -0.227], [0.259, -0.203], [0.277, -0.178], [0.293, -0.151], [0.306, -0.122], [0.316, -0.092], [0.324, -0.062], [0.328, -0.031], [0.36, 0.0], [0.358, 0.031], [0.354, 0.062], [0.347, 0.093], [0.338, 0.123], [0.326, 0.152], [0.311, 0.179], [0.294, 0.206], [0.275, 0.231], [0.254, 0.254], [0.231, 0.275], [0.206, 0.294], [0.18, 0.311], [0.152, 0.326], [0.123, 0.338], [0.093, 0.347], [0.062, 0.354], [0.031, 0.358], [0.0, 0.36], [-0.031, 0.358], [-0.062, 0.354], [-0.093, 0.347], [-0.123, 0.338], [-0.152, 0.326], [-0.179, 0.311], [-0.206, 0.294], [-0.231, 0.275], [-0.254, 0.254], [-0.275, 0.231], [-0.294, 0.206], [-0.311, 0.18], [-0.326, 0.152], [-0.338, 0.123], [-0.347, 0.093], [-0.354, 0.062], [-0.358, 0.031], [-0.36, 0.0], [-0.358, -0.031], [-0.354, -0.062], [-0.347, -0.093], [-0.338, -0.123], [-0.326, -0.152], [-0.311, -0.18], [-0.294, -0.206], [-0.275, -0.231], [-0.254, -0.254], [-0.231, -0.275], [-0.206, -0.294], [-0.18, -0.311], [-0.152, -0.326], [-0.123, -0.338], [-0.093, -0.347], [-0.062, -0.354], [-0.031, -0.358], [0.0, -0.36], [0.031, -0.358], [0.062, -0.354], [0.093, -0.347], [0.123, -0.338], [0.152, -0.326], [0.179, -0.311], [0.206, -0.294], [0.231, -0.275], [0.254, -0.254], [0.275, -0.231], [0.294, -0.206], [0.311, -0.179], [0.326, -0.152], [0.338, -0.123], [0.347, -0.093], [0.354, -0.062], [0.358, -0.031], [0.39, 0.0], [0.388, 0.031], [0.384, 0.062], [0.378, 0.093], [0.369, 0.123], [0.358, 0.152], [0.345, 0.181], [0.329, 0.208], [0.311, 0.234], [0.291, 0.258], [0.27, 0.281], [0.246, 0.302], [0.221, 0.32], [0.194, 0.337], [0.167, 0.352], [0.138, 0.364], [0.108, 0.374], [0.078, 0.382], [0.047, 0.387], [0.015, 0.389], [-0.015, 0.389], [-0.047, 0.387], [-0.078, 0.382], [-0.108, 0.374], [-0.138, 0.364], [-0.167, 0.352], [-0.195, 0.337], [-0.221, 0.32], [-0.246, 0.302], [-0.27, 0.281], [-0.291, 0.258], [-0.311, 0.234], [-0.329, 0.208], [-0.345, 0.181], [-0.358, 0.152], [-0.369, 0.123], [-0.378, 0.093], [-0.384, 0.062], [-0.388, 0.031], [-0.39, 0.0], [-0.388, -0.031], [-0.384, -0.062], [-0.378, -0.093], [-0.369, -0.123], [-0.358, -0.152], [-0.345, -0.181], [-0.329, -0.208], [-0.311, -0.234], [-0.291, -0.258], [-0.27, -0.281], [-0.246, -0.302], [-0.221, -0.32], [-0.194, -0.337], [-0.167, -0.352], [-0.138, -0.364], [-0.108, -0.374], [-0.078, -0.382], [-0.047, -0.387], [-0.015, -0.389], [0.015, -0.389], [0.047, -0.387], [0.078, -0.382], [0.108, -0.374], [0.138, -0.364], [0.167, -0.352], [0.194, -0.337], [0.221, -0.32], [0.246, -0.302], [0.27, -0.281], [0.291, -0.258], [0.311, -0.234], [0.329, -0.208], [0.345, -0.181], [0.358, -0.152], [0.369, -0.123], [0.378, -0.093], [0.384, -0.062], [0.388, -0.031]])
num_antennas = antenna_coords.shape[0]

# Alternatively, remove most of the coords from the computed set
antenna_coords = antenna_coords[0:-1:10]
num_antennas = antenna_coords.shape[0]

# Plot the geometry of the antenna
print('Num antennas:', num_antennas)

plt.scatter(antenna_coords[:, 0], antenna_coords[:, 1])
plt.xlabel('x (m)')
plt.ylabel('y (m)')
plt.title('Positions of antennas in array')
plt.show()



## Choose some random feed parameters for the array, and calculate the resulting far-field gain.

# Define main params
min_gain = -40                              # dBi Any gain lower than this we consider inconsequential (and we don't plot it either)
max_angle_of_interest = 90                  # degrees; angle either side of centre in one direction
frequency = 6e9                             # Hz
speed_of_light = 3e8                        # m/s
wavelength = speed_of_light / frequency     # m
num_sample_angles = 101

c=299792458
freq = 30e9
wavelength = c / freq
k = 2 * np.pi / wavelength
factor_scaling = k / 100


# Define some functions
def rad(angle_deg):
  return np.radians(angle_deg)

def deg(angle_rad):
  return np.degrees(angle_rad)

# UV coords, linear scale from -1 to 1
max_u = np.sin(rad(max_angle_of_interest))
sample_angles_u = np.linspace(-max_u, max_u, num_sample_angles)
sample_angles_v = sample_angles_u

# XY coords, from -90 to 90
sample_angles_x = np.arcsin(sample_angles_u) * 180 / np.pi
sample_angles_y = sample_angles_x

# Grid
grid_coords_u, grid_coords_v = np.meshgrid(sample_angles_u, sample_angles_v)


# Elementary feed antenna pattern
antenna_pattern = np.zeros((num_antennas, num_sample_angles, num_sample_angles), dtype="complex64")

for i in range(num_antennas):
  antenna_pattern[i, :, :] = np.exp(1j / wavelength * (antenna_coords[i, 0] * grid_coords_u + antenna_coords[i, 1] * grid_coords_v))


plt.figure(figsize=(10, 8))
for i in range(len(antenna_coords)):
    plt.contourf(sample_angles_u, sample_angles_v, np.abs(antenna_pattern[i, :, :]), alpha=0.6, label=f'Antenna {i+1}')

plt.title('Motifs de rayonnement des antennes')
plt.xlabel('Coordonnée u')
plt.ylabel('Coordonnée v')
plt.colorbar(label='Amplitude')
plt.legend()
plt.show()



# Generate random feed parameters
#feed_params_initial = (np.random.random(num_antennas) + (np.random.random(num_antennas) * 2 - 1) * 1j)
# Alternative feed_params to create a known pattern
feed_params_initial = np.ones(num_antennas) 
print("Initial feed parameters: ", feed_params_initial)

# Calculate directive gain
def get_directive_gain_from_feed_params(feed_params):
    gain = np.zeros((num_sample_angles, num_sample_angles))
    for i in range(num_antennas):
        gain = gain + feed_params[i] * antenna_pattern[i, :, :]
    gain = 20 * np.log10(np.abs(gain))
    normalised_gain = gain - np.max(gain)
    return np.clip(normalised_gain, min_gain, None)

directive_gain_initial = get_directive_gain_from_feed_params(feed_params_initial)




"""Define plot functions.
Plot the directive gain.

"""



# 2D heatmap visualisation, plot directive gain
def plot_far_field_uv(gain, figAx=None):
    if figAx is None:
        plt.close('all')
        fig, ax = plt.subplots()
    else:
        fig, ax = figAx
    divider = make_axes_locatable(ax)
    cax = divider.append_axes('right', size='5%', pad=0.05)
    image = ax.imshow(gain, cmap='viridis')
    ax.set_xlabel('U (sine of azimuth)')
    ax.set_ylabel('V (sine of elevation)')
    ax.set_title('directive gain (dB)')
    fig.colorbar(image, cax=cax, orientation='vertical')

plot_far_field_uv(directive_gain_initial)
plt.show()


# 3D surface plot
def plot_far_field_uv_3d():
    fig = plt.figure()
    ax = plt.axes(projection='3d')
    ax.plot_surface(grid_coords_u, grid_coords_v, directive_gain_initial,
                    cmap='viridis', edgecolor='none')
    ax.set_xlabel('U (sine of azimuth)')
    ax.set_ylabel('V (sine of elevation)')
    ax.set_zlabel('Normalised directive gain (dB)')
    plt.title('3D surface plot')
    
plot_far_field_uv_3d()
plt.show()

    




## Target far field

# How wide do we want the beam to be
target_beam_width = 10 # deg

# Where do we want the beam to point? (random)
target_angle_x = (np.random.random(1) - 0.5) * max_angle_of_interest * 2
target_angle_y = (np.random.random(1) - 0.5) * max_angle_of_interest * 2

print('Target angle (x, y): ', target_angle_x, target_angle_y)


def get_target_far_field(target_angle_x, target_angle_y, target_beam_width):
    
    target_far_field = np.zeros((num_sample_angles, num_sample_angles), dtype=bool)
    
    dist_x = sample_angles_x - target_angle_x
    dist_y = sample_angles_y - target_angle_y
    dist_x_array = np.tile(dist_x[:, np.newaxis], (1, num_sample_angles))
    dist_y_array = np.tile(dist_y[np.newaxis, :], (num_sample_angles, 1))
    dist = np.sqrt(dist_x_array ** 2 + dist_y_array ** 2)
    target_far_field[dist < target_beam_width / 2] = True
    # catch the case where no sample angle falls within the target beam
    if not np.any(target_far_field):
        # Just find the single closest sample angle
        ids_of_target_angles_x = np.argmin(dist, axis=0)[0]
        ids_of_target_angles_y = np.argmin(dist, axis=1)[1]
        target_far_field[ids_of_target_angles_x, ids_of_target_angles_y] = True
    return target_far_field


def plot_target_far_field_uv(target_far_field, figAx=None):
    if figAx is None:
        plt.close('all')
        fig, ax = plt.subplots()
    else:
        fig, ax = figAx
    image = ax.imshow(target_far_field, cmap='viridis')
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_title('Target far field (Boolean)')
    
    
target_far_field = get_target_far_field(target_angle_x, target_angle_y, target_beam_width)
plot_target_far_field_uv(target_far_field)
plt.show()


def time_delayer(data, do_phase_delay, do_time_delay, delay_time_ps, freq, samp_rate):
    delayed_data = data
    if do_phase_delay == True:
        delayed_data = delayed_data * np.exp(1j*2*np.pi*freq*delay_time_ps*1E-12)
    if do_time_delay == True:
        # Create and apply fractional delay filter
        # Dr. Marc Lichtman  https://pysdr.org/content/sync.html#adding-a-delay
        delay = np.int64(samp_rate) * delay_time_ps * 1E-12   # fractional delay, in samples
        N = 21 # number of taps
        n = np.arange(-N//2, N//2) # ...-3,-2,-1,0,1,2,3...
        h = np.sinc(n - delay) # calc filter taps
        h *= np.hamming(N) # window the filter to make sure it decays to 0 on both sides
        h /= np.sum(h) # normalize to get unity gain, we don't want to change the amplitude/power
        delayed_data = np.convolve(delayed_data, h) # apply filter
        delayed_data = delayed_data[int(N/2+1):-int(N/2-1)]    # drop the first and last N/2 results
    return delayed_data

sine_wave = np.sin(np.linspace(0,2*np.pi))
plt.subplot(2,1,1)
plt.plot(sine_wave)
sine_wave_delayed = time_delayer(sine_wave, True, False, 0.5*1E+12, 1,1000)
plt.subplot(2,1,2)
plt.plot(sine_wave_delayed)
plt.show()
plt.tight_layout()






